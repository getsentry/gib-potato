<% content_for :title, "Tractor Snake" %>

<% content_for :head do %>
  <style>
    /* White background, canvas spans the full viewport */
    body { background: #fff; color: #000; margin: 0; }
    #board { display:block; width:100vw; height:100vh; background:#fff; }
    /* Bottom-right HUD (unstyled content; positioned only) */
    #hud { position: fixed; right: 8px; bottom: 8px; display:flex; gap:8px; align-items:center; }
  </style>
<% end %>

<canvas id="board" role="img"></canvas>
<div id="hud">
  <div>Potatoes: <span id="count">0</span></div>
  <button id="reset">Reset</button>
</div>

<script>
  const CELL_MIN = 28;   // base size for an emoji tile (px)
  const CELL_MAX = 40;   // cap so emojis don't get huge on massive screens

  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const countEl = document.getElementById('count');
  const resetBtn = document.getElementById('reset');

  let COLS = 20, ROWS = 20, CELL = CELL_MIN;
  let snake, dir, queuedDir, potato, eaten, tickMs, timer, running, gameOver;
  const TICK_MS_START = 140;
  const SPEEDUP_EVERY = 5;
  const SPEEDUP_DELTA = 6;

  function computeGrid() {
    const w = window.innerWidth, h = window.innerHeight;
    let tentative = Math.max(CELL_MIN, Math.min(CELL_MAX, Math.floor(Math.min(w/22, h/22))));
    if (tentative < CELL_MIN) tentative = CELL_MIN;
    CELL = tentative;
    COLS = Math.max(10, Math.floor(w / CELL));
    ROWS = Math.max(10, Math.floor(h / CELL));
    canvas.width  = COLS * CELL;  // exact pixel grid to avoid subpixel blur
    canvas.height = ROWS * CELL;
  }

  function init() {
    computeGrid();
    snake = [{ x: Math.floor(COLS/2), y: Math.floor(ROWS/2) }];
    dir = { x: 1, y: 0 };
    queuedDir = dir;
    potato = spawnPotato();
    eaten = 0;
    tickMs = TICK_MS_START;
    running = false;
    gameOver = false;
    countEl.textContent = eaten;
    draw();
    stopLoop();
  }

  function startLoop() { if (!timer) { running = true; timer = setInterval(tick, tickMs); } }
  function stopLoop() { clearInterval(timer); timer = null; }

  function spawnPotato() {
    let p;
    do { p = { x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS) }; }
    while (snake.some(s => s.x === p.x && s.y === p.y));
    return p;
  }

  function setDir(nx, ny) {
    if ((nx === -dir.x && ny === -dir.y)) return; // no instant reverse
    queuedDir = { x: nx, y: ny };
    if (!running && !gameOver) startLoop();
  }

  function onKey(e) {
    const k = e.key.toLowerCase();
    if (["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d","2","4","6","8"].includes(k)) e.preventDefault();
    if (k === 'arrowup' || k === 'w' || k === '8') setDir(0,-1);
    else if (k === 'arrowdown' || k === 's' || k === '2') setDir(0,1);
    else if (k === 'arrowleft' || k === 'a' || k === '4') setDir(-1,0);
    else if (k === 'arrowright' || k === 'd' || k === '6') setDir(1,0);
    else if (k === 'r') doReset();
  }

  function tick() {
    dir = queuedDir;
    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
    // Border = viewport edges (the canvas bounds)
    if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) return endGame();
    if (snake.some((s, i) => i && s.x === head.x && s.y === head.y)) return endGame();

    snake.unshift(head);
    if (head.x === potato.x && head.y === potato.y) {
      eaten++;
      countEl.textContent = eaten;
      potato = spawnPotato();
      maybeSpeedUp();
    } else {
      snake.pop();
    }
    draw();
  }

  function maybeSpeedUp() {
    if (eaten % SPEEDUP_EVERY === 0 && tickMs > 60) {
      tickMs = Math.max(60, tickMs - SPEEDUP_DELTA);
      stopLoop();
      startLoop();
    }
  }

  function endGame() { gameOver = true; stopLoop(); draw(); }
  function doReset() { init(); }

  function drawCell(x, y, glyph) {
    const px = x * CELL, py = y * CELL;
    // clear cell to white
    ctx.fillStyle = '#fff';
    ctx.fillRect(px, py, CELL, CELL);
    ctx.font = `${Math.floor(CELL*0.9)}px system-ui, \"Apple Color Emoji\", \"Segoe UI Emoji\"`;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#000';
    ctx.fillText(glyph, px + CELL/2, py + CELL/2 + 1);
  }

  function drawBoardBG() {
    // Full white background
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    // Thin black border along the viewport/canvas edges
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.strokeRect(0.5, 0.5, canvas.width-1, canvas.height-1);
  }

  function draw() {
    drawBoardBG();
    // potato to collect
    drawCell(potato.x, potato.y, 'ðŸ¥”');
    // snake
    for (let i = snake.length-1; i>=0; i--) {
      const s = snake[i];
      if (i === 0) drawCell(s.x, s.y, 'ðŸšœ');
      else drawCell(s.x, s.y, 'ðŸ¥”');
    }

    if (gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px system-ui, -apple-system, Segoe UI, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Game Over â€” Reset or press R', canvas.width/2, canvas.height/2);
    }
  }

  // --- Wire up ---
  window.addEventListener('keydown', onKey, { passive:false });
  resetBtn.addEventListener('click', doReset);

  // Handle resizing: re-compute grid & reset for simplicity
  window.addEventListener('resize', () => {
    const wasRunning = running && !gameOver;
    init();
    if (wasRunning) startLoop();
  });

  init();
</script>
