import {
  BAGGAGE_HEADER_NAME,
  TRACEPARENT_REGEXP,
  _nullishCoalesce,
  _optionalChain,
  addInstrumentationHandler,
  browserPerformanceTimeOrigin,
  createBaggage,
  dropUndefinedKeys,
  dynamicRequire,
  extractPathForTransaction,
  extractTraceparentData,
  fill,
  getCurrentHub,
  getGlobalObject,
  getMainCarrier,
  getNumberOfUrlSegments,
  getSentryBaggageItems,
  htmlTreeAsString,
  isBaggageMutable,
  isInstanceOf,
  isMatchingPattern,
  isNaN,
  isNodeEnv,
  isRegExp,
  isThenable,
  loadModule,
  logger,
  mergeAndSerializeBaggage,
  parseBaggageSetMutability,
  stripUrlQueryAndFragment,
  timestampWithMs,
  uuid4
} from "./chunk-BX3TOKNE.js";
import {
  __export
} from "./chunk-FAW2VN4A.js";

// node_modules/@sentry/tracing/esm/utils.js
function hasTracingEnabled(maybeOptions) {
  var client = getCurrentHub().getClient();
  var options = maybeOptions || client && client.getOptions();
  return !!options && ("tracesSampleRate" in options || "tracesSampler" in options);
}
function getActiveTransaction(maybeHub) {
  var hub = maybeHub || getCurrentHub();
  var scope = hub.getScope();
  return scope && scope.getTransaction();
}
function msToSec(time) {
  return time / 1e3;
}

// node_modules/@sentry/tracing/esm/errors.js
function registerErrorInstrumentation() {
  addInstrumentationHandler("error", errorCallback);
  addInstrumentationHandler("unhandledrejection", errorCallback);
}
function errorCallback() {
  var activeTransaction = getActiveTransaction();
  if (activeTransaction) {
    var status = "internal_error";
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);
    activeTransaction.setStatus(status);
  }
}

// node_modules/@sentry/tracing/esm/span.js
var SpanRecorder = class {
  __init() {
    this.spans = [];
  }
  constructor(maxlen = 1e3) {
    ;
    SpanRecorder.prototype.__init.call(this);
    this._maxlen = maxlen;
  }
  add(span) {
    if (this.spans.length > this._maxlen) {
      span.spanRecorder = void 0;
    } else {
      this.spans.push(span);
    }
  }
};
var Span = class {
  __init2() {
    this.traceId = uuid4();
  }
  __init3() {
    this.spanId = uuid4().substring(16);
  }
  __init4() {
    this.startTimestamp = timestampWithMs();
  }
  __init5() {
    this.tags = {};
  }
  __init6() {
    this.data = {};
  }
  constructor(spanContext) {
    ;
    Span.prototype.__init2.call(this);
    Span.prototype.__init3.call(this);
    Span.prototype.__init4.call(this);
    Span.prototype.__init5.call(this);
    Span.prototype.__init6.call(this);
    if (!spanContext) {
      return this;
    }
    if (spanContext.traceId) {
      this.traceId = spanContext.traceId;
    }
    if (spanContext.spanId) {
      this.spanId = spanContext.spanId;
    }
    if (spanContext.parentSpanId) {
      this.parentSpanId = spanContext.parentSpanId;
    }
    if ("sampled" in spanContext) {
      this.sampled = spanContext.sampled;
    }
    if (spanContext.op) {
      this.op = spanContext.op;
    }
    if (spanContext.description) {
      this.description = spanContext.description;
    }
    if (spanContext.data) {
      this.data = spanContext.data;
    }
    if (spanContext.tags) {
      this.tags = spanContext.tags;
    }
    if (spanContext.status) {
      this.status = spanContext.status;
    }
    if (spanContext.startTimestamp) {
      this.startTimestamp = spanContext.startTimestamp;
    }
    if (spanContext.endTimestamp) {
      this.endTimestamp = spanContext.endTimestamp;
    }
  }
  startChild(spanContext) {
    var childSpan = new Span({
      ...spanContext,
      parentSpanId: this.spanId,
      sampled: this.sampled,
      traceId: this.traceId
    });
    childSpan.spanRecorder = this.spanRecorder;
    if (childSpan.spanRecorder) {
      childSpan.spanRecorder.add(childSpan);
    }
    childSpan.transaction = this.transaction;
    if ((typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && childSpan.transaction) {
      var opStr = spanContext && spanContext.op || "< unknown op >";
      var nameStr = childSpan.transaction.name || "< unknown name >";
      var idStr = childSpan.transaction.spanId;
      var logMessage = `[Tracing] Starting '${opStr}' span on transaction '${nameStr}' (${idStr}).`;
      childSpan.transaction.metadata.spanMetadata[childSpan.spanId] = { logMessage };
      logger.log(logMessage);
    }
    return childSpan;
  }
  setTag(key, value) {
    this.tags = { ...this.tags, [key]: value };
    return this;
  }
  setData(key, value) {
    this.data = { ...this.data, [key]: value };
    return this;
  }
  setStatus(value) {
    this.status = value;
    return this;
  }
  setHttpStatus(httpStatus) {
    this.setTag("http.status_code", String(httpStatus));
    var spanStatus = spanStatusfromHttpCode(httpStatus);
    if (spanStatus !== "unknown_error") {
      this.setStatus(spanStatus);
    }
    return this;
  }
  isSuccess() {
    return this.status === "ok";
  }
  finish(endTimestamp) {
    if ((typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && this.transaction && this.transaction.spanId !== this.spanId) {
      const { logMessage } = this.transaction.metadata.spanMetadata[this.spanId];
      if (logMessage) {
        logger.log(logMessage.replace("Starting", "Finishing"));
      }
    }
    this.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : timestampWithMs();
  }
  toTraceparent() {
    let sampledString = "";
    if (this.sampled !== void 0) {
      sampledString = this.sampled ? "-1" : "-0";
    }
    return `${this.traceId}-${this.spanId}${sampledString}`;
  }
  toContext() {
    return dropUndefinedKeys({
      data: this.data,
      description: this.description,
      endTimestamp: this.endTimestamp,
      op: this.op,
      parentSpanId: this.parentSpanId,
      sampled: this.sampled,
      spanId: this.spanId,
      startTimestamp: this.startTimestamp,
      status: this.status,
      tags: this.tags,
      traceId: this.traceId
    });
  }
  updateWithContext(spanContext) {
    this.data = _nullishCoalesce(spanContext.data, () => ({}));
    this.description = spanContext.description;
    this.endTimestamp = spanContext.endTimestamp;
    this.op = spanContext.op;
    this.parentSpanId = spanContext.parentSpanId;
    this.sampled = spanContext.sampled;
    this.spanId = _nullishCoalesce(spanContext.spanId, () => this.spanId);
    this.startTimestamp = _nullishCoalesce(spanContext.startTimestamp, () => this.startTimestamp);
    this.status = spanContext.status;
    this.tags = _nullishCoalesce(spanContext.tags, () => ({}));
    this.traceId = _nullishCoalesce(spanContext.traceId, () => this.traceId);
    return this;
  }
  getTraceContext() {
    return dropUndefinedKeys({
      data: Object.keys(this.data).length > 0 ? this.data : void 0,
      description: this.description,
      op: this.op,
      parent_span_id: this.parentSpanId,
      span_id: this.spanId,
      status: this.status,
      tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
      trace_id: this.traceId
    });
  }
  toJSON() {
    return dropUndefinedKeys({
      data: Object.keys(this.data).length > 0 ? this.data : void 0,
      description: this.description,
      op: this.op,
      parent_span_id: this.parentSpanId,
      span_id: this.spanId,
      start_timestamp: this.startTimestamp,
      status: this.status,
      tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
      timestamp: this.endTimestamp,
      trace_id: this.traceId
    });
  }
};
function spanStatusfromHttpCode(httpStatus) {
  if (httpStatus < 400 && httpStatus >= 100) {
    return "ok";
  }
  if (httpStatus >= 400 && httpStatus < 500) {
    switch (httpStatus) {
      case 401:
        return "unauthenticated";
      case 403:
        return "permission_denied";
      case 404:
        return "not_found";
      case 409:
        return "already_exists";
      case 413:
        return "failed_precondition";
      case 429:
        return "resource_exhausted";
      default:
        return "invalid_argument";
    }
  }
  if (httpStatus >= 500 && httpStatus < 600) {
    switch (httpStatus) {
      case 501:
        return "unimplemented";
      case 503:
        return "unavailable";
      case 504:
        return "deadline_exceeded";
      default:
        return "internal_error";
    }
  }
  return "unknown_error";
}

// node_modules/@sentry/tracing/esm/transaction.js
var Transaction = class extends Span {
  __init() {
    this._measurements = {};
  }
  constructor(transactionContext, hub) {
    super(transactionContext);
    Transaction.prototype.__init.call(this);
    ;
    this._hub = hub || getCurrentHub();
    this._name = transactionContext.name || "";
    this.metadata = {
      ...transactionContext.metadata,
      spanMetadata: {}
    };
    this._trimEnd = transactionContext.trimEnd;
    this.transaction = this;
  }
  get name() {
    return this._name;
  }
  set name(newName) {
    this._name = newName;
    this.metadata.source = "custom";
  }
  setName(name, source = "custom") {
    this.name = name;
    this.metadata.source = source;
  }
  initSpanRecorder(maxlen = 1e3) {
    if (!this.spanRecorder) {
      this.spanRecorder = new SpanRecorder(maxlen);
    }
    this.spanRecorder.add(this);
  }
  setMeasurement(name, value, unit = "") {
    this._measurements[name] = { value, unit };
  }
  setMetadata(newMetadata) {
    this.metadata = { ...this.metadata, ...newMetadata };
  }
  finish(endTimestamp) {
    if (this.endTimestamp !== void 0) {
      return void 0;
    }
    if (!this.name) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
      this.name = "<unlabeled transaction>";
    }
    super.finish(endTimestamp);
    if (this.sampled !== true) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
      var client = this._hub.getClient();
      if (client) {
        client.recordDroppedEvent("sample_rate", "transaction");
      }
      return void 0;
    }
    var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter((s) => s !== this && s.endTimestamp) : [];
    if (this._trimEnd && finishedSpans.length > 0) {
      this.endTimestamp = finishedSpans.reduce((prev, current) => {
        if (prev.endTimestamp && current.endTimestamp) {
          return prev.endTimestamp > current.endTimestamp ? prev : current;
        }
        return prev;
      }).endTimestamp;
    }
    var metadata = this.metadata;
    var transaction = {
      contexts: {
        trace: this.getTraceContext()
      },
      spans: finishedSpans,
      start_timestamp: this.startTimestamp,
      tags: this.tags,
      timestamp: this.endTimestamp,
      transaction: this.name,
      type: "transaction",
      sdkProcessingMetadata: {
        ...metadata,
        baggage: this.getBaggage()
      },
      ...metadata.source && {
        transaction_info: {
          source: metadata.source
        }
      }
    };
    var hasMeasurements = Object.keys(this._measurements).length > 0;
    if (hasMeasurements) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(
        "[Measurements] Adding measurements to transaction",
        JSON.stringify(this._measurements, void 0, 2)
      );
      transaction.measurements = this._measurements;
    }
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);
    return this._hub.captureEvent(transaction);
  }
  toContext() {
    var spanContext = super.toContext();
    return dropUndefinedKeys({
      ...spanContext,
      name: this.name,
      trimEnd: this._trimEnd
    });
  }
  updateWithContext(transactionContext) {
    super.updateWithContext(transactionContext);
    this.name = _nullishCoalesce(transactionContext.name, () => "");
    this._trimEnd = transactionContext.trimEnd;
    return this;
  }
  getBaggage() {
    var existingBaggage = this.metadata.baggage;
    var finalBaggage = !existingBaggage || isBaggageMutable(existingBaggage) ? this._populateBaggageWithSentryValues(existingBaggage) : existingBaggage;
    this.metadata.baggage = finalBaggage;
    return finalBaggage;
  }
  _populateBaggageWithSentryValues(baggage = createBaggage({})) {
    var hub = this._hub || getCurrentHub();
    var client = hub && hub.getClient();
    if (!client)
      return baggage;
    const { environment, release } = client.getOptions() || {};
    const { publicKey: public_key } = client.getDsn() || {};
    var sample_rate = this.metadata && this.metadata.transactionSampling && this.metadata.transactionSampling.rate && this.metadata.transactionSampling.rate.toString();
    var scope = hub.getScope();
    const { segment: user_segment } = scope && scope.getUser() || {};
    var source = this.metadata.source;
    var transaction = source && source !== "url" ? this.name : void 0;
    return createBaggage(
      dropUndefinedKeys({
        environment,
        release,
        transaction,
        user_segment,
        public_key,
        trace_id: this.traceId,
        sample_rate,
        ...getSentryBaggageItems(baggage)
      }),
      "",
      false
    );
  }
};

// node_modules/@sentry/tracing/esm/idletransaction.js
var DEFAULT_IDLE_TIMEOUT = 1e3;
var DEFAULT_FINAL_TIMEOUT = 3e4;
var HEARTBEAT_INTERVAL = 5e3;
var IdleTransactionSpanRecorder = class extends SpanRecorder {
  constructor(_pushActivity, _popActivity, transactionSpanId, maxlen) {
    super(maxlen);
    this._pushActivity = _pushActivity;
    this._popActivity = _popActivity;
    this.transactionSpanId = transactionSpanId;
    ;
  }
  add(span) {
    if (span.spanId !== this.transactionSpanId) {
      span.finish = (endTimestamp) => {
        span.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : timestampWithMs();
        this._popActivity(span.spanId);
      };
      if (span.endTimestamp === void 0) {
        this._pushActivity(span.spanId);
      }
    }
    super.add(span);
  }
};
var IdleTransaction = class extends Transaction {
  __init() {
    this.activities = {};
  }
  __init2() {
    this._heartbeatCounter = 0;
  }
  __init3() {
    this._finished = false;
  }
  __init4() {
    this._beforeFinishCallbacks = [];
  }
  constructor(transactionContext, _idleHub, _idleTimeout = DEFAULT_IDLE_TIMEOUT, _finalTimeout = DEFAULT_FINAL_TIMEOUT, _onScope = false) {
    super(transactionContext, _idleHub);
    this._idleHub = _idleHub;
    this._idleTimeout = _idleTimeout;
    this._finalTimeout = _finalTimeout;
    this._onScope = _onScope;
    IdleTransaction.prototype.__init.call(this);
    IdleTransaction.prototype.__init2.call(this);
    IdleTransaction.prototype.__init3.call(this);
    IdleTransaction.prototype.__init4.call(this);
    ;
    if (_onScope) {
      clearActiveTransaction(_idleHub);
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);
      _idleHub.configureScope((scope) => scope.setSpan(this));
    }
    this._startIdleTimeout();
    setTimeout(() => {
      if (!this._finished) {
        this.setStatus("deadline_exceeded");
        this.finish();
      }
    }, this._finalTimeout);
  }
  finish(endTimestamp = timestampWithMs()) {
    this._finished = true;
    this.activities = {};
    if (this.spanRecorder) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Tracing] finishing IdleTransaction", new Date(endTimestamp * 1e3).toISOString(), this.op);
      for (var callback of this._beforeFinishCallbacks) {
        callback(this, endTimestamp);
      }
      this.spanRecorder.spans = this.spanRecorder.spans.filter((span) => {
        if (span.spanId === this.spanId) {
          return true;
        }
        if (!span.endTimestamp) {
          span.endTimestamp = endTimestamp;
          span.setStatus("cancelled");
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span, void 0, 2));
        }
        var keepSpan = span.startTimestamp < endTimestamp;
        if (!keepSpan) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(
            "[Tracing] discarding Span since it happened after Transaction was finished",
            JSON.stringify(span, void 0, 2)
          );
        }
        return keepSpan;
      });
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Tracing] flushing IdleTransaction");
    } else {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Tracing] No active IdleTransaction");
    }
    if (this._onScope) {
      clearActiveTransaction(this._idleHub);
    }
    return super.finish(endTimestamp);
  }
  registerBeforeFinishCallback(callback) {
    this._beforeFinishCallbacks.push(callback);
  }
  initSpanRecorder(maxlen) {
    if (!this.spanRecorder) {
      var pushActivity = (id) => {
        if (this._finished) {
          return;
        }
        this._pushActivity(id);
      };
      var popActivity = (id) => {
        if (this._finished) {
          return;
        }
        this._popActivity(id);
      };
      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("Starting heartbeat");
      this._pingHeartbeat();
    }
    this.spanRecorder.add(this);
  }
  _cancelIdleTimeout() {
    if (this._idleTimeoutID) {
      clearTimeout(this._idleTimeoutID);
      this._idleTimeoutID = void 0;
    }
  }
  _startIdleTimeout(endTimestamp) {
    this._cancelIdleTimeout();
    this._idleTimeoutID = setTimeout(() => {
      if (!this._finished && Object.keys(this.activities).length === 0) {
        this.finish(endTimestamp);
      }
    }, this._idleTimeout);
  }
  _pushActivity(spanId) {
    this._cancelIdleTimeout();
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`[Tracing] pushActivity: ${spanId}`);
    this.activities[spanId] = true;
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
  }
  _popActivity(spanId) {
    if (this.activities[spanId]) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`[Tracing] popActivity ${spanId}`);
      delete this.activities[spanId];
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
    }
    if (Object.keys(this.activities).length === 0) {
      var endTimestamp = timestampWithMs() + this._idleTimeout / 1e3;
      this._startIdleTimeout(endTimestamp);
    }
  }
  _beat() {
    if (this._finished) {
      return;
    }
    var heartbeatString = Object.keys(this.activities).join("");
    if (heartbeatString === this._prevHeartbeatString) {
      this._heartbeatCounter += 1;
    } else {
      this._heartbeatCounter = 1;
    }
    this._prevHeartbeatString = heartbeatString;
    if (this._heartbeatCounter >= 3) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
      this.setStatus("deadline_exceeded");
      this.finish();
    } else {
      this._pingHeartbeat();
    }
  }
  _pingHeartbeat() {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);
    setTimeout(() => {
      this._beat();
    }, HEARTBEAT_INTERVAL);
  }
};
function clearActiveTransaction(hub) {
  var scope = hub.getScope();
  if (scope) {
    var transaction = scope.getTransaction();
    if (transaction) {
      scope.setSpan(void 0);
    }
  }
}

// node_modules/@sentry/tracing/esm/hubextensions.js
function traceHeaders() {
  var scope = this.getScope();
  if (scope) {
    var span = scope.getSpan();
    if (span) {
      return {
        "sentry-trace": span.toTraceparent()
      };
    }
  }
  return {};
}
function sample(transaction, options, samplingContext) {
  if (!hasTracingEnabled(options)) {
    transaction.sampled = false;
    return transaction;
  }
  if (transaction.sampled !== void 0) {
    transaction.setMetadata({
      transactionSampling: { method: "explicitly_set" }
    });
    return transaction;
  }
  let sampleRate;
  if (typeof options.tracesSampler === "function") {
    sampleRate = options.tracesSampler(samplingContext);
    transaction.setMetadata({
      transactionSampling: {
        method: "client_sampler",
        rate: Number(sampleRate)
      }
    });
  } else if (samplingContext.parentSampled !== void 0) {
    sampleRate = samplingContext.parentSampled;
    transaction.setMetadata({
      transactionSampling: { method: "inheritance" }
    });
  } else {
    sampleRate = options.tracesSampleRate;
    transaction.setMetadata({
      transactionSampling: {
        method: "client_rate",
        rate: Number(sampleRate)
      }
    });
  }
  if (!isValidSampleRate(sampleRate)) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
    transaction.sampled = false;
    return transaction;
  }
  if (!sampleRate) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(
      `[Tracing] Discarding transaction because ${typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
    );
    transaction.sampled = false;
    return transaction;
  }
  transaction.sampled = Math.random() < sampleRate;
  if (!transaction.sampled) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(
      `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
        sampleRate
      )})`
    );
    return transaction;
  }
  (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`[Tracing] starting ${transaction.op} transaction - ${transaction.name}`);
  return transaction;
}
function isValidSampleRate(rate) {
  if (isNaN(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn(
      `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
        rate
      )} of type ${JSON.stringify(typeof rate)}.`
    );
    return false;
  }
  if (rate < 0 || rate > 1) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);
    return false;
  }
  return true;
}
function _startTransaction(transactionContext, customSamplingContext) {
  var client = this.getClient();
  var options = client && client.getOptions() || {};
  let transaction = new Transaction(transactionContext, this);
  transaction = sample(transaction, options, {
    parentSampled: transactionContext.parentSampled,
    transactionContext,
    ...customSamplingContext
  });
  if (transaction.sampled) {
    transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
  }
  return transaction;
}
function startIdleTransaction(hub, transactionContext, idleTimeout, finalTimeout, onScope, customSamplingContext) {
  var client = hub.getClient();
  var options = client && client.getOptions() || {};
  let transaction = new IdleTransaction(transactionContext, hub, idleTimeout, finalTimeout, onScope);
  transaction = sample(transaction, options, {
    parentSampled: transactionContext.parentSampled,
    transactionContext,
    ...customSamplingContext
  });
  if (transaction.sampled) {
    transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
  }
  return transaction;
}
function _addTracingExtensions() {
  var carrier = getMainCarrier();
  if (!carrier.__SENTRY__) {
    return;
  }
  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
  if (!carrier.__SENTRY__.extensions.startTransaction) {
    carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
  }
  if (!carrier.__SENTRY__.extensions.traceHeaders) {
    carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
  }
}
function _autoloadDatabaseIntegrations() {
  var carrier = getMainCarrier();
  if (!carrier.__SENTRY__) {
    return;
  }
  var packageToIntegrationMapping = {
    mongodb() {
      var integration = dynamicRequire(module, "./integrations/node/mongo");
      return new integration.Mongo();
    },
    mongoose() {
      var integration = dynamicRequire(module, "./integrations/node/mongo");
      return new integration.Mongo({ mongoose: true });
    },
    mysql() {
      var integration = dynamicRequire(module, "./integrations/node/mysql");
      return new integration.Mysql();
    },
    pg() {
      var integration = dynamicRequire(module, "./integrations/node/postgres");
      return new integration.Postgres();
    }
  };
  var mappedPackages = Object.keys(packageToIntegrationMapping).filter((moduleName) => !!loadModule(moduleName)).map((pkg) => {
    try {
      return packageToIntegrationMapping[pkg]();
    } catch (e) {
      return void 0;
    }
  }).filter((p) => p);
  if (mappedPackages.length > 0) {
    carrier.__SENTRY__.integrations = [...carrier.__SENTRY__.integrations || [], ...mappedPackages];
  }
}
function addExtensionMethods() {
  _addTracingExtensions();
  if (isNodeEnv()) {
    _autoloadDatabaseIntegrations();
  }
  registerErrorInstrumentation();
}

// node_modules/@sentry/tracing/esm/integrations/index.js
var integrations_exports = {};
__export(integrations_exports, {
  Apollo: () => Apollo,
  BrowserTracing: () => BrowserTracing,
  Express: () => Express,
  GraphQL: () => GraphQL,
  Mongo: () => Mongo,
  Mysql: () => Mysql,
  Postgres: () => Postgres,
  Prisma: () => Prisma
});

// node_modules/@sentry/tracing/esm/integrations/node/express.js
var Express = class {
  static __initStatic() {
    this.id = "Express";
  }
  __init() {
    this.name = Express.id;
  }
  constructor(options = {}) {
    ;
    Express.prototype.__init.call(this);
    this._router = options.router || options.app;
    this._methods = (Array.isArray(options.methods) ? options.methods : []).concat("use");
  }
  setupOnce() {
    if (!this._router) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.error("ExpressIntegration is missing an Express instance");
      return;
    }
    instrumentMiddlewares(this._router, this._methods);
    instrumentRouter(this._router);
  }
};
Express.__initStatic();
function wrap(fn, method) {
  var arity = fn.length;
  switch (arity) {
    case 2: {
      return function(req, res) {
        var transaction = res.__sentry_transaction;
        if (transaction) {
          var span = transaction.startChild({
            description: fn.name,
            op: `express.middleware.${method}`
          });
          res.once("finish", () => {
            span.finish();
          });
        }
        return fn.call(this, req, res);
      };
    }
    case 3: {
      return function(req, res, next) {
        var transaction = res.__sentry_transaction;
        var span = _optionalChain([transaction, "optionalAccess", (_) => _.startChild, "call", (_2) => _2({
          description: fn.name,
          op: `express.middleware.${method}`
        })]);
        fn.call(this, req, res, function(...args) {
          _optionalChain([span, "optionalAccess", (_3) => _3.finish, "call", (_4) => _4()]);
          next.call(this, ...args);
        });
      };
    }
    case 4: {
      return function(err, req, res, next) {
        var transaction = res.__sentry_transaction;
        var span = _optionalChain([transaction, "optionalAccess", (_5) => _5.startChild, "call", (_6) => _6({
          description: fn.name,
          op: `express.middleware.${method}`
        })]);
        fn.call(this, err, req, res, function(...args) {
          _optionalChain([span, "optionalAccess", (_7) => _7.finish, "call", (_8) => _8()]);
          next.call(this, ...args);
        });
      };
    }
    default: {
      throw new Error(`Express middleware takes 2-4 arguments. Got: ${arity}`);
    }
  }
}
function wrapMiddlewareArgs(args, method) {
  return args.map((arg) => {
    if (typeof arg === "function") {
      return wrap(arg, method);
    }
    if (Array.isArray(arg)) {
      return arg.map((a) => {
        if (typeof a === "function") {
          return wrap(a, method);
        }
        return a;
      });
    }
    return arg;
  });
}
function patchMiddleware(router, method) {
  var originalCallback = router[method];
  router[method] = function(...args) {
    return originalCallback.call(this, ...wrapMiddlewareArgs(args, method));
  };
  return router;
}
function instrumentMiddlewares(router, methods = []) {
  methods.forEach((method) => patchMiddleware(router, method));
}
function instrumentRouter(appOrRouter) {
  var isApp = "settings" in appOrRouter;
  if (isApp && appOrRouter._router === void 0 && appOrRouter.lazyrouter) {
    appOrRouter.lazyrouter();
  }
  var router = isApp ? appOrRouter._router : appOrRouter;
  if (!router) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.debug("Cannot instrument router for URL Parameterization (did not find a valid router).");
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.debug("Routing instrumentation is currently only supported in Express 4.");
    return;
  }
  var routerProto = Object.getPrototypeOf(router);
  var originalProcessParams = routerProto.process_params;
  routerProto.process_params = function process_params(layer, called, req, res, done) {
    if (!req._reconstructedRoute) {
      req._reconstructedRoute = "";
    }
    const { layerRoutePath, isRegex, isArray, numExtraSegments } = getLayerRoutePathInfo(layer);
    var partialRoute = layerRoutePath || layer.path || "";
    var finalPartialRoute = partialRoute.split("/").filter((segment) => segment.length > 0 && (isRegex || isArray || !segment.includes("*"))).join("/");
    if (finalPartialRoute && finalPartialRoute.length > 0) {
      req._reconstructedRoute += `/${finalPartialRoute}${isRegex ? "/" : ""}`;
    }
    var urlLength = getNumberOfUrlSegments(req.originalUrl || "") + numExtraSegments;
    var routeLength = getNumberOfUrlSegments(req._reconstructedRoute);
    if (urlLength === routeLength) {
      var transaction = res.__sentry_transaction;
      if (transaction && transaction.metadata.source !== "custom") {
        var finalRoute = req._reconstructedRoute || "/";
        transaction.setName(...extractPathForTransaction(req, { path: true, method: true, customRoute: finalRoute }));
      }
    }
    return originalProcessParams.call(this, layer, called, req, res, done);
  };
}
function getLayerRoutePathInfo(layer) {
  var lrp = _optionalChain([layer, "access", (_9) => _9.route, "optionalAccess", (_10) => _10.path]);
  var isRegex = isRegExp(lrp);
  var isArray = Array.isArray(lrp);
  if (!lrp) {
    return { isRegex, isArray, numExtraSegments: 0 };
  }
  var numExtraSegments = isArray ? Math.max(getNumberOfArrayUrlSegments(lrp) - getNumberOfUrlSegments(layer.path || ""), 0) : 0;
  var layerRoutePath = getLayerRoutePathString(isArray, lrp);
  return { layerRoutePath, isRegex, isArray, numExtraSegments };
}
function getNumberOfArrayUrlSegments(routesArray) {
  return routesArray.reduce((accNumSegments, currentRoute) => {
    return accNumSegments + getNumberOfUrlSegments(currentRoute.toString());
  }, 0);
}
function getLayerRoutePathString(isArray, lrp) {
  if (isArray) {
    return lrp.map((r) => r.toString()).join(",");
  }
  return lrp && lrp.toString();
}

// node_modules/@sentry/tracing/esm/integrations/node/postgres.js
var Postgres = class {
  static __initStatic() {
    this.id = "Postgres";
  }
  __init() {
    this.name = Postgres.id;
  }
  constructor(options = {}) {
    ;
    Postgres.prototype.__init.call(this);
    this._usePgNative = !!options.usePgNative;
  }
  setupOnce(_, getCurrentHub2) {
    var pkg = loadModule("pg");
    if (!pkg) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.error("Postgres Integration was unable to require `pg` package.");
      return;
    }
    if (this._usePgNative && !_optionalChain([pkg, "access", (_2) => _2.native, "optionalAccess", (_3) => _3.Client])) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.error("Postgres Integration was unable to access 'pg-native' bindings.");
      return;
    }
    const { Client } = this._usePgNative ? pkg.native : pkg;
    fill(Client.prototype, "query", function(orig) {
      return function(config, values, callback) {
        var scope = getCurrentHub2().getScope();
        var parentSpan = _optionalChain([scope, "optionalAccess", (_4) => _4.getSpan, "call", (_5) => _5()]);
        var span = _optionalChain([parentSpan, "optionalAccess", (_6) => _6.startChild, "call", (_7) => _7({
          description: typeof config === "string" ? config : config.text,
          op: "db"
        })]);
        if (typeof callback === "function") {
          return orig.call(this, config, values, function(err, result) {
            _optionalChain([span, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
            callback(err, result);
          });
        }
        if (typeof values === "function") {
          return orig.call(this, config, function(err, result) {
            _optionalChain([span, "optionalAccess", (_10) => _10.finish, "call", (_11) => _11()]);
            values(err, result);
          });
        }
        var rv = typeof values !== "undefined" ? orig.call(this, config, values) : orig.call(this, config);
        if (isThenable(rv)) {
          return rv.then((res) => {
            _optionalChain([span, "optionalAccess", (_12) => _12.finish, "call", (_13) => _13()]);
            return res;
          });
        }
        _optionalChain([span, "optionalAccess", (_14) => _14.finish, "call", (_15) => _15()]);
        return rv;
      };
    });
  }
};
Postgres.__initStatic();

// node_modules/@sentry/tracing/esm/integrations/node/mysql.js
var Mysql = class {
  constructor() {
    Mysql.prototype.__init.call(this);
  }
  static __initStatic() {
    this.id = "Mysql";
  }
  __init() {
    this.name = Mysql.id;
  }
  setupOnce(_, getCurrentHub2) {
    var pkg = loadModule("mysql/lib/Connection.js");
    if (!pkg) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.error("Mysql Integration was unable to require `mysql` package.");
      return;
    }
    fill(pkg, "createQuery", function(orig) {
      return function(options, values, callback) {
        var scope = getCurrentHub2().getScope();
        var parentSpan = _optionalChain([scope, "optionalAccess", (_2) => _2.getSpan, "call", (_3) => _3()]);
        var span = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.startChild, "call", (_5) => _5({
          description: typeof options === "string" ? options : options.sql,
          op: "db"
        })]);
        if (typeof callback === "function") {
          return orig.call(this, options, values, function(err, result, fields) {
            _optionalChain([span, "optionalAccess", (_6) => _6.finish, "call", (_7) => _7()]);
            callback(err, result, fields);
          });
        }
        if (typeof values === "function") {
          return orig.call(this, options, function(err, result, fields) {
            _optionalChain([span, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
            values(err, result, fields);
          });
        }
        return orig.call(this, options, values, callback);
      };
    });
  }
};
Mysql.__initStatic();

// node_modules/@sentry/tracing/esm/integrations/node/mongo.js
var OPERATIONS = [
  "aggregate",
  "bulkWrite",
  "countDocuments",
  "createIndex",
  "createIndexes",
  "deleteMany",
  "deleteOne",
  "distinct",
  "drop",
  "dropIndex",
  "dropIndexes",
  "estimatedDocumentCount",
  "find",
  "findOne",
  "findOneAndDelete",
  "findOneAndReplace",
  "findOneAndUpdate",
  "indexes",
  "indexExists",
  "indexInformation",
  "initializeOrderedBulkOp",
  "insertMany",
  "insertOne",
  "isCapped",
  "mapReduce",
  "options",
  "parallelCollectionScan",
  "rename",
  "replaceOne",
  "stats",
  "updateMany",
  "updateOne"
];
var OPERATION_SIGNATURES = {
  bulkWrite: ["operations"],
  countDocuments: ["query"],
  createIndex: ["fieldOrSpec"],
  createIndexes: ["indexSpecs"],
  deleteMany: ["filter"],
  deleteOne: ["filter"],
  distinct: ["key", "query"],
  dropIndex: ["indexName"],
  find: ["query"],
  findOne: ["query"],
  findOneAndDelete: ["filter"],
  findOneAndReplace: ["filter", "replacement"],
  findOneAndUpdate: ["filter", "update"],
  indexExists: ["indexes"],
  insertMany: ["docs"],
  insertOne: ["doc"],
  mapReduce: ["map", "reduce"],
  rename: ["newName"],
  replaceOne: ["filter", "doc"],
  updateMany: ["filter", "update"],
  updateOne: ["filter", "update"]
};
var Mongo = class {
  static __initStatic() {
    this.id = "Mongo";
  }
  __init() {
    this.name = Mongo.id;
  }
  constructor(options = {}) {
    ;
    Mongo.prototype.__init.call(this);
    this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;
    this._describeOperations = "describeOperations" in options ? options.describeOperations : true;
    this._useMongoose = !!options.useMongoose;
  }
  setupOnce(_, getCurrentHub2) {
    var moduleName = this._useMongoose ? "mongoose" : "mongodb";
    var pkg = loadModule(moduleName);
    if (!pkg) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.error(`Mongo Integration was unable to require \`${moduleName}\` package.`);
      return;
    }
    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub2);
  }
  _instrumentOperations(collection, operations, getCurrentHub2) {
    operations.forEach((operation) => this._patchOperation(collection, operation, getCurrentHub2));
  }
  _patchOperation(collection, operation, getCurrentHub2) {
    if (!(operation in collection.prototype))
      return;
    var getSpanContext = this._getSpanContextFromOperationArguments.bind(this);
    fill(collection.prototype, operation, function(orig) {
      return function(...args) {
        var lastArg = args[args.length - 1];
        var scope = getCurrentHub2().getScope();
        var parentSpan = _optionalChain([scope, "optionalAccess", (_2) => _2.getSpan, "call", (_3) => _3()]);
        if (typeof lastArg !== "function" || operation === "mapReduce" && args.length === 2) {
          var span = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.startChild, "call", (_5) => _5(getSpanContext(this, operation, args))]);
          var maybePromise = orig.call(this, ...args);
          if (isThenable(maybePromise)) {
            return maybePromise.then((res) => {
              _optionalChain([span, "optionalAccess", (_6) => _6.finish, "call", (_7) => _7()]);
              return res;
            });
          } else {
            _optionalChain([span, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
            return maybePromise;
          }
        }
        var span = _optionalChain([parentSpan, "optionalAccess", (_10) => _10.startChild, "call", (_11) => _11(getSpanContext(this, operation, args.slice(0, -1)))]);
        return orig.call(this, ...args.slice(0, -1), function(err, result) {
          _optionalChain([span, "optionalAccess", (_12) => _12.finish, "call", (_13) => _13()]);
          lastArg(err, result);
        });
      };
    });
  }
  _getSpanContextFromOperationArguments(collection, operation, args) {
    var data = {
      collectionName: collection.collectionName,
      dbName: collection.dbName,
      namespace: collection.namespace
    };
    var spanContext = {
      op: "db",
      description: operation,
      data
    };
    var signature = OPERATION_SIGNATURES[operation];
    var shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;
    if (!signature || !shouldDescribe) {
      return spanContext;
    }
    try {
      if (operation === "mapReduce") {
        const [map, reduce] = args;
        data[signature[0]] = typeof map === "string" ? map : map.name || "<anonymous>";
        data[signature[1]] = typeof reduce === "string" ? reduce : reduce.name || "<anonymous>";
      } else {
        for (let i = 0; i < signature.length; i++) {
          data[signature[i]] = JSON.stringify(args[i]);
        }
      }
    } catch (_oO) {
    }
    return spanContext;
  }
};
Mongo.__initStatic();

// node_modules/@sentry/tracing/esm/integrations/node/prisma.js
function isValidPrismaClient(possibleClient) {
  return possibleClient && !!possibleClient["$use"];
}
var Prisma = class {
  static __initStatic() {
    this.id = "Prisma";
  }
  __init() {
    this.name = Prisma.id;
  }
  constructor(options = {}) {
    ;
    Prisma.prototype.__init.call(this);
    if (isValidPrismaClient(options.client)) {
      this._client = options.client;
    } else {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn(
        `Unsupported Prisma client provided to PrismaIntegration. Provided client: ${JSON.stringify(options.client)}`
      );
    }
  }
  setupOnce(_, getCurrentHub2) {
    if (!this._client) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.error("PrismaIntegration is missing a Prisma Client Instance");
      return;
    }
    this._client.$use((params, next) => {
      var scope = getCurrentHub2().getScope();
      var parentSpan = _optionalChain([scope, "optionalAccess", (_2) => _2.getSpan, "call", (_3) => _3()]);
      var action = params.action;
      var model = params.model;
      var span = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.startChild, "call", (_5) => _5({
        description: model ? `${model} ${action}` : action,
        op: "db.prisma"
      })]);
      var rv = next(params);
      if (isThenable(rv)) {
        return rv.then((res) => {
          _optionalChain([span, "optionalAccess", (_6) => _6.finish, "call", (_7) => _7()]);
          return res;
        });
      }
      _optionalChain([span, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
      return rv;
    });
  }
};
Prisma.__initStatic();

// node_modules/@sentry/tracing/esm/integrations/node/graphql.js
var GraphQL = class {
  constructor() {
    GraphQL.prototype.__init.call(this);
  }
  static __initStatic() {
    this.id = "GraphQL";
  }
  __init() {
    this.name = GraphQL.id;
  }
  setupOnce(_, getCurrentHub2) {
    var pkg = loadModule("graphql/execution/execute.js");
    if (!pkg) {
      logger.error("GraphQL Integration was unable to require graphql/execution package.");
      return;
    }
    fill(pkg, "execute", function(orig) {
      return function(...args) {
        var scope = getCurrentHub2().getScope();
        var parentSpan = _optionalChain([scope, "optionalAccess", (_2) => _2.getSpan, "call", (_3) => _3()]);
        var span = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.startChild, "call", (_5) => _5({
          description: "execute",
          op: "db.graphql"
        })]);
        _optionalChain([scope, "optionalAccess", (_6) => _6.setSpan, "call", (_7) => _7(span)]);
        var rv = orig.call(this, ...args);
        if (isThenable(rv)) {
          return rv.then((res) => {
            _optionalChain([span, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
            _optionalChain([scope, "optionalAccess", (_10) => _10.setSpan, "call", (_11) => _11(parentSpan)]);
            return res;
          });
        }
        _optionalChain([span, "optionalAccess", (_12) => _12.finish, "call", (_13) => _13()]);
        _optionalChain([scope, "optionalAccess", (_14) => _14.setSpan, "call", (_15) => _15(parentSpan)]);
        return rv;
      };
    });
  }
};
GraphQL.__initStatic();

// node_modules/@sentry/tracing/esm/integrations/node/apollo.js
var Apollo = class {
  constructor() {
    Apollo.prototype.__init.call(this);
  }
  static __initStatic() {
    this.id = "Apollo";
  }
  __init() {
    this.name = Apollo.id;
  }
  setupOnce(_, getCurrentHub2) {
    var pkg = loadModule("apollo-server-core");
    if (!pkg) {
      logger.error("Apollo Integration was unable to require apollo-server-core package.");
      return;
    }
    fill(pkg.ApolloServerBase.prototype, "constructSchema", function(orig) {
      return function() {
        var resolvers = Array.isArray(this.config.resolvers) ? this.config.resolvers : [this.config.resolvers];
        this.config.resolvers = resolvers.map((model) => {
          Object.keys(model).forEach((resolverGroupName) => {
            Object.keys(model[resolverGroupName]).forEach((resolverName) => {
              if (typeof model[resolverGroupName][resolverName] !== "function") {
                return;
              }
              wrapResolver(model, resolverGroupName, resolverName, getCurrentHub2);
            });
          });
          return model;
        });
        return orig.call(this);
      };
    });
  }
};
Apollo.__initStatic();
function wrapResolver(model, resolverGroupName, resolverName, getCurrentHub2) {
  fill(model[resolverGroupName], resolverName, function(orig) {
    return function(...args) {
      var scope = getCurrentHub2().getScope();
      var parentSpan = _optionalChain([scope, "optionalAccess", (_2) => _2.getSpan, "call", (_3) => _3()]);
      var span = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.startChild, "call", (_5) => _5({
        description: `${resolverGroupName}.${resolverName}`,
        op: "db.graphql.apollo"
      })]);
      var rv = orig.call(this, ...args);
      if (isThenable(rv)) {
        return rv.then((res) => {
          _optionalChain([span, "optionalAccess", (_6) => _6.finish, "call", (_7) => _7()]);
          return res;
        });
      }
      _optionalChain([span, "optionalAccess", (_8) => _8.finish, "call", (_9) => _9()]);
      return rv;
    };
  });
}

// node_modules/@sentry/tracing/esm/browser/backgroundtab.js
var global = getGlobalObject();
function registerBackgroundTabDetection() {
  if (global && global.document) {
    global.document.addEventListener("visibilitychange", () => {
      var activeTransaction = getActiveTransaction();
      if (global.document.hidden && activeTransaction) {
        var statusType = "cancelled";
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(
          `[Tracing] Transaction: ${statusType} -> since tab moved to the background, op: ${activeTransaction.op}`
        );
        if (!activeTransaction.status) {
          activeTransaction.setStatus(statusType);
        }
        activeTransaction.setTag("visibilitychange", "document.hidden");
        activeTransaction.finish();
      }
    });
  } else {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
  }
}

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/bindReporter.js
var bindReporter = (callback, metric, reportAllChanges) => {
  let prevValue;
  return (forceReport) => {
    if (metric.value >= 0) {
      if (forceReport || reportAllChanges) {
        metric.delta = metric.value - (prevValue || 0);
        if (metric.delta || prevValue === void 0) {
          prevValue = metric.value;
          callback(metric);
        }
      }
    }
  };
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/generateUniqueID.js
var generateUniqueID = () => {
  return `v2-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/initMetric.js
var initMetric = (name, value) => {
  return {
    name,
    value: _nullishCoalesce(value, () => -1),
    delta: 0,
    entries: [],
    id: generateUniqueID()
  };
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/observe.js
var observe = (type, callback) => {
  try {
    if (PerformanceObserver.supportedEntryTypes.includes(type)) {
      if (type === "first-input" && !("PerformanceEventTiming" in self)) {
        return;
      }
      var po = new PerformanceObserver((l) => l.getEntries().map(callback));
      po.observe({ type, buffered: true });
      return po;
    }
  } catch (e) {
  }
  return;
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/onHidden.js
var onHidden = (cb, once) => {
  var onHiddenOrPageHide = (event) => {
    if (event.type === "pagehide" || getGlobalObject().document.visibilityState === "hidden") {
      cb(event);
      if (once) {
        removeEventListener("visibilitychange", onHiddenOrPageHide, true);
        removeEventListener("pagehide", onHiddenOrPageHide, true);
      }
    }
  };
  addEventListener("visibilitychange", onHiddenOrPageHide, true);
  addEventListener("pagehide", onHiddenOrPageHide, true);
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/getCLS.js
var getCLS = (onReport, reportAllChanges) => {
  var metric = initMetric("CLS", 0);
  let report;
  let sessionValue = 0;
  let sessionEntries = [];
  var entryHandler = (entry) => {
    if (entry && !entry.hadRecentInput) {
      var firstSessionEntry = sessionEntries[0];
      var lastSessionEntry = sessionEntries[sessionEntries.length - 1];
      if (sessionValue && sessionEntries.length !== 0 && entry.startTime - lastSessionEntry.startTime < 1e3 && entry.startTime - firstSessionEntry.startTime < 5e3) {
        sessionValue += entry.value;
        sessionEntries.push(entry);
      } else {
        sessionValue = entry.value;
        sessionEntries = [entry];
      }
      if (sessionValue > metric.value) {
        metric.value = sessionValue;
        metric.entries = sessionEntries;
        if (report) {
          report();
        }
      }
    }
  };
  var po = observe("layout-shift", entryHandler);
  if (po) {
    report = bindReporter(onReport, metric, reportAllChanges);
    onHidden(() => {
      po.takeRecords().map(entryHandler);
      report(true);
    });
  }
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/getVisibilityWatcher.js
var firstHiddenTime = -1;
var initHiddenTime = () => {
  return getGlobalObject().document.visibilityState === "hidden" ? 0 : Infinity;
};
var trackChanges = () => {
  onHidden(({ timeStamp }) => {
    firstHiddenTime = timeStamp;
  }, true);
};
var getVisibilityWatcher = () => {
  if (firstHiddenTime < 0) {
    firstHiddenTime = initHiddenTime();
    trackChanges();
  }
  return {
    get firstHiddenTime() {
      return firstHiddenTime;
    }
  };
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/getFID.js
var getFID = (onReport, reportAllChanges) => {
  var visibilityWatcher = getVisibilityWatcher();
  var metric = initMetric("FID");
  let report;
  var entryHandler = (entry) => {
    if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {
      metric.value = entry.processingStart - entry.startTime;
      metric.entries.push(entry);
      report(true);
    }
  };
  var po = observe("first-input", entryHandler);
  if (po) {
    report = bindReporter(onReport, metric, reportAllChanges);
    onHidden(() => {
      po.takeRecords().map(entryHandler);
      po.disconnect();
    }, true);
  }
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/getLCP.js
var reportedMetricIDs = {};
var getLCP = (onReport, reportAllChanges) => {
  var visibilityWatcher = getVisibilityWatcher();
  var metric = initMetric("LCP");
  let report;
  var entryHandler = (entry) => {
    var value = entry.startTime;
    if (value < visibilityWatcher.firstHiddenTime) {
      metric.value = value;
      metric.entries.push(entry);
    }
    if (report) {
      report();
    }
  };
  var po = observe("largest-contentful-paint", entryHandler);
  if (po) {
    report = bindReporter(onReport, metric, reportAllChanges);
    var stopListening = () => {
      if (!reportedMetricIDs[metric.id]) {
        po.takeRecords().map(entryHandler);
        po.disconnect();
        reportedMetricIDs[metric.id] = true;
        report(true);
      }
    };
    ["keydown", "click"].forEach((type) => {
      addEventListener(type, stopListening, { once: true, capture: true });
    });
    onHidden(stopListening, true);
  }
};

// node_modules/@sentry/tracing/esm/browser/metrics/utils.js
function isMeasurementValue(value) {
  return typeof value === "number" && isFinite(value);
}
function _startChild(transaction, { startTimestamp, ...ctx }) {
  if (startTimestamp && transaction.startTimestamp > startTimestamp) {
    transaction.startTimestamp = startTimestamp;
  }
  return transaction.startChild({
    startTimestamp,
    ...ctx
  });
}

// node_modules/@sentry/tracing/esm/browser/metrics/index.js
var global2 = getGlobalObject();
function getBrowserPerformanceAPI() {
  return global2 && global2.addEventListener && global2.performance;
}
var _performanceCursor = 0;
var _measurements = {};
var _lcpEntry;
var _clsEntry;
function startTrackingWebVitals(reportAllChanges = false) {
  var performance = getBrowserPerformanceAPI();
  if (performance && browserPerformanceTimeOrigin) {
    if (performance.mark) {
      global2.performance.mark("sentry-tracing-init");
    }
    _trackCLS();
    _trackLCP(reportAllChanges);
    _trackFID();
  }
}
function startTrackingLongTasks() {
  var entryHandler = (entry) => {
    var transaction = getActiveTransaction();
    if (!transaction) {
      return;
    }
    var startTime = msToSec(browserPerformanceTimeOrigin + entry.startTime);
    var duration = msToSec(entry.duration);
    transaction.startChild({
      description: "Long Task",
      op: "ui.long-task",
      startTimestamp: startTime,
      endTimestamp: startTime + duration
    });
  };
  observe("longtask", entryHandler);
}
function _trackCLS() {
  getCLS((metric) => {
    var entry = metric.entries.pop();
    if (!entry) {
      return;
    }
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Measurements] Adding CLS");
    _measurements["cls"] = { value: metric.value, unit: "" };
    _clsEntry = entry;
  });
}
function _trackLCP(reportAllChanges) {
  getLCP((metric) => {
    var entry = metric.entries.pop();
    if (!entry) {
      return;
    }
    var timeOrigin = msToSec(browserPerformanceTimeOrigin);
    var startTime = msToSec(entry.startTime);
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Measurements] Adding LCP");
    _measurements["lcp"] = { value: metric.value, unit: "millisecond" };
    _measurements["mark.lcp"] = { value: timeOrigin + startTime, unit: "second" };
    _lcpEntry = entry;
  }, reportAllChanges);
}
function _trackFID() {
  getFID((metric) => {
    var entry = metric.entries.pop();
    if (!entry) {
      return;
    }
    var timeOrigin = msToSec(browserPerformanceTimeOrigin);
    var startTime = msToSec(entry.startTime);
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Measurements] Adding FID");
    _measurements["fid"] = { value: metric.value, unit: "millisecond" };
    _measurements["mark.fid"] = { value: timeOrigin + startTime, unit: "second" };
  });
}
function addPerformanceEntries(transaction) {
  var performance = getBrowserPerformanceAPI();
  if (!performance || !global2.performance.getEntries || !browserPerformanceTimeOrigin) {
    return;
  }
  (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Tracing] Adding & adjusting spans using Performance API");
  var timeOrigin = msToSec(browserPerformanceTimeOrigin);
  var performanceEntries = performance.getEntries();
  let responseStartTimestamp;
  let requestStartTimestamp;
  performanceEntries.slice(_performanceCursor).forEach((entry) => {
    var startTime = msToSec(entry.startTime);
    var duration = msToSec(entry.duration);
    if (transaction.op === "navigation" && timeOrigin + startTime < transaction.startTimestamp) {
      return;
    }
    switch (entry.entryType) {
      case "navigation": {
        _addNavigationSpans(transaction, entry, timeOrigin);
        responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);
        requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);
        break;
      }
      case "mark":
      case "paint":
      case "measure": {
        var startTimestamp = _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
        var firstHidden = getVisibilityWatcher();
        var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;
        if (entry.name === "first-paint" && shouldRecord) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Measurements] Adding FP");
          _measurements["fp"] = { value: entry.startTime, unit: "millisecond" };
          _measurements["mark.fp"] = { value: startTimestamp, unit: "second" };
        }
        if (entry.name === "first-contentful-paint" && shouldRecord) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Measurements] Adding FCP");
          _measurements["fcp"] = { value: entry.startTime, unit: "millisecond" };
          _measurements["mark.fcp"] = { value: startTimestamp, unit: "second" };
        }
        break;
      }
      case "resource": {
        var resourceName = entry.name.replace(global2.location.origin, "");
        _addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
        break;
      }
      default:
    }
  });
  _performanceCursor = Math.max(performanceEntries.length - 1, 0);
  _trackNavigator(transaction);
  if (transaction.op === "pageload") {
    if (typeof responseStartTimestamp === "number") {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Measurements] Adding TTFB");
      _measurements["ttfb"] = {
        value: (responseStartTimestamp - transaction.startTimestamp) * 1e3,
        unit: "millisecond"
      };
      if (typeof requestStartTimestamp === "number" && requestStartTimestamp <= responseStartTimestamp) {
        _measurements["ttfb.requestTime"] = {
          value: (responseStartTimestamp - requestStartTimestamp) * 1e3,
          unit: "millisecond"
        };
      }
    }
    ["fcp", "fp", "lcp"].forEach((name) => {
      if (!_measurements[name] || timeOrigin >= transaction.startTimestamp) {
        return;
      }
      var oldValue = _measurements[name].value;
      var measurementTimestamp = timeOrigin + msToSec(oldValue);
      var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1e3);
      var delta = normalizedValue - oldValue;
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);
      _measurements[name].value = normalizedValue;
    });
    if (_measurements["mark.fid"] && _measurements["fid"]) {
      _startChild(transaction, {
        description: "first input delay",
        endTimestamp: _measurements["mark.fid"].value + msToSec(_measurements["fid"].value),
        op: "web.vitals",
        startTimestamp: _measurements["mark.fid"].value
      });
    }
    if (!("fcp" in _measurements)) {
      delete _measurements.cls;
    }
    Object.keys(_measurements).forEach((measurementName) => {
      transaction.setMeasurement(
        measurementName,
        _measurements[measurementName].value,
        _measurements[measurementName].unit
      );
    });
    _tagMetricInfo(transaction);
  }
  _lcpEntry = void 0;
  _clsEntry = void 0;
  _measurements = {};
}
function _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
  var measureStartTimestamp = timeOrigin + startTime;
  var measureEndTimestamp = measureStartTimestamp + duration;
  _startChild(transaction, {
    description: entry.name,
    endTimestamp: measureEndTimestamp,
    op: entry.entryType,
    startTimestamp: measureStartTimestamp
  });
  return measureStartTimestamp;
}
function _addNavigationSpans(transaction, entry, timeOrigin) {
  ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((event) => {
    _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
  });
  _addPerformanceNavigationTiming(transaction, entry, "secureConnection", timeOrigin, "TLS/SSL", "connectEnd");
  _addPerformanceNavigationTiming(transaction, entry, "fetch", timeOrigin, "cache", "domainLookupStart");
  _addPerformanceNavigationTiming(transaction, entry, "domainLookup", timeOrigin, "DNS");
  _addRequest(transaction, entry, timeOrigin);
}
function _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, description, eventEnd) {
  var end = eventEnd ? entry[eventEnd] : entry[`${event}End`];
  var start = entry[`${event}Start`];
  if (!start || !end) {
    return;
  }
  _startChild(transaction, {
    op: "browser",
    description: _nullishCoalesce(description, () => event),
    startTimestamp: timeOrigin + msToSec(start),
    endTimestamp: timeOrigin + msToSec(end)
  });
}
function _addRequest(transaction, entry, timeOrigin) {
  _startChild(transaction, {
    op: "browser",
    description: "request",
    startTimestamp: timeOrigin + msToSec(entry.requestStart),
    endTimestamp: timeOrigin + msToSec(entry.responseEnd)
  });
  _startChild(transaction, {
    op: "browser",
    description: "response",
    startTimestamp: timeOrigin + msToSec(entry.responseStart),
    endTimestamp: timeOrigin + msToSec(entry.responseEnd)
  });
}
function _addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
  if (entry.initiatorType === "xmlhttprequest" || entry.initiatorType === "fetch") {
    return;
  }
  var data = {};
  if ("transferSize" in entry) {
    data["Transfer Size"] = entry.transferSize;
  }
  if ("encodedBodySize" in entry) {
    data["Encoded Body Size"] = entry.encodedBodySize;
  }
  if ("decodedBodySize" in entry) {
    data["Decoded Body Size"] = entry.decodedBodySize;
  }
  var startTimestamp = timeOrigin + startTime;
  var endTimestamp = startTimestamp + duration;
  _startChild(transaction, {
    description: resourceName,
    endTimestamp,
    op: entry.initiatorType ? `resource.${entry.initiatorType}` : "resource",
    startTimestamp,
    data
  });
}
function _trackNavigator(transaction) {
  var navigator = global2.navigator;
  if (!navigator) {
    return;
  }
  var connection = navigator.connection;
  if (connection) {
    if (connection.effectiveType) {
      transaction.setTag("effectiveConnectionType", connection.effectiveType);
    }
    if (connection.type) {
      transaction.setTag("connectionType", connection.type);
    }
    if (isMeasurementValue(connection.rtt)) {
      _measurements["connection.rtt"] = { value: connection.rtt, unit: "millisecond" };
    }
    if (isMeasurementValue(connection.downlink)) {
      _measurements["connection.downlink"] = { value: connection.downlink, unit: "" };
    }
  }
  if (isMeasurementValue(navigator.deviceMemory)) {
    transaction.setTag("deviceMemory", `${navigator.deviceMemory} GB`);
  }
  if (isMeasurementValue(navigator.hardwareConcurrency)) {
    transaction.setTag("hardwareConcurrency", String(navigator.hardwareConcurrency));
  }
}
function _tagMetricInfo(transaction) {
  if (_lcpEntry) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Measurements] Adding LCP Data");
    if (_lcpEntry.element) {
      transaction.setTag("lcp.element", htmlTreeAsString(_lcpEntry.element));
    }
    if (_lcpEntry.id) {
      transaction.setTag("lcp.id", _lcpEntry.id);
    }
    if (_lcpEntry.url) {
      transaction.setTag("lcp.url", _lcpEntry.url.trim().slice(0, 200));
    }
    transaction.setTag("lcp.size", _lcpEntry.size);
  }
  if (_clsEntry && _clsEntry.sources) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("[Measurements] Adding CLS Data");
    _clsEntry.sources.forEach(
      (source, index) => transaction.setTag(`cls.source.${index + 1}`, htmlTreeAsString(source.node))
    );
  }
}

// node_modules/@sentry/tracing/esm/browser/request.js
var DEFAULT_TRACING_ORIGINS = ["localhost", /^\//];
var defaultRequestInstrumentationOptions = {
  traceFetch: true,
  traceXHR: true,
  tracingOrigins: DEFAULT_TRACING_ORIGINS
};
function instrumentOutgoingRequests(_options) {
  const { traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest } = {
    ...defaultRequestInstrumentationOptions,
    ..._options
  };
  var urlMap = {};
  var defaultShouldCreateSpan = (url) => {
    if (urlMap[url]) {
      return urlMap[url];
    }
    var origins = tracingOrigins;
    urlMap[url] = origins.some((origin) => isMatchingPattern(url, origin)) && !isMatchingPattern(url, "sentry_key");
    return urlMap[url];
  };
  let shouldCreateSpan = defaultShouldCreateSpan;
  if (typeof shouldCreateSpanForRequest === "function") {
    shouldCreateSpan = (url) => {
      return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
    };
  }
  var spans = {};
  if (traceFetch) {
    addInstrumentationHandler("fetch", (handlerData) => {
      fetchCallback(handlerData, shouldCreateSpan, spans);
    });
  }
  if (traceXHR) {
    addInstrumentationHandler("xhr", (handlerData) => {
      xhrCallback(handlerData, shouldCreateSpan, spans);
    });
  }
}
function fetchCallback(handlerData, shouldCreateSpan, spans) {
  if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
    return;
  }
  if (handlerData.endTimestamp) {
    var spanId = handlerData.fetchData.__span;
    if (!spanId)
      return;
    var span = spans[spanId];
    if (span) {
      if (handlerData.response) {
        span.setHttpStatus(handlerData.response.status);
      } else if (handlerData.error) {
        span.setStatus("internal_error");
      }
      span.finish();
      delete spans[spanId];
    }
    return;
  }
  var activeTransaction = getActiveTransaction();
  if (activeTransaction) {
    var span = activeTransaction.startChild({
      data: {
        ...handlerData.fetchData,
        type: "fetch"
      },
      description: `${handlerData.fetchData.method} ${handlerData.fetchData.url}`,
      op: "http.client"
    });
    handlerData.fetchData.__span = span.spanId;
    spans[span.spanId] = span;
    var request = handlerData.args[0] = handlerData.args[0];
    var options = handlerData.args[1] = handlerData.args[1] || {};
    options.headers = addTracingHeaders(request, activeTransaction.getBaggage(), span, options);
  }
}
function addTracingHeaders(request, incomingBaggage, span, options) {
  let headers = options.headers;
  if (isInstanceOf(request, Request)) {
    headers = request.headers;
  }
  if (headers) {
    if (typeof headers.append === "function") {
      headers.append("sentry-trace", span.toTraceparent());
      headers.append(BAGGAGE_HEADER_NAME, mergeAndSerializeBaggage(incomingBaggage, headers.get(BAGGAGE_HEADER_NAME)));
    } else if (Array.isArray(headers)) {
      const [, headerBaggageString] = headers.find(([key, _]) => key === BAGGAGE_HEADER_NAME);
      headers = [
        ...headers,
        ["sentry-trace", span.toTraceparent()],
        [BAGGAGE_HEADER_NAME, mergeAndSerializeBaggage(incomingBaggage, headerBaggageString)]
      ];
    } else {
      headers = {
        ...headers,
        "sentry-trace": span.toTraceparent(),
        baggage: mergeAndSerializeBaggage(incomingBaggage, headers.baggage)
      };
    }
  } else {
    headers = { "sentry-trace": span.toTraceparent(), baggage: mergeAndSerializeBaggage(incomingBaggage) };
  }
  return headers;
}
function xhrCallback(handlerData, shouldCreateSpan, spans) {
  if (!hasTracingEnabled() || handlerData.xhr && handlerData.xhr.__sentry_own_request__ || !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))) {
    return;
  }
  var xhr = handlerData.xhr.__sentry_xhr__;
  if (handlerData.endTimestamp) {
    var spanId = handlerData.xhr.__sentry_xhr_span_id__;
    if (!spanId)
      return;
    var span = spans[spanId];
    if (span) {
      span.setHttpStatus(xhr.status_code);
      span.finish();
      delete spans[spanId];
    }
    return;
  }
  var activeTransaction = getActiveTransaction();
  if (activeTransaction) {
    var span = activeTransaction.startChild({
      data: {
        ...xhr.data,
        type: "xhr",
        method: xhr.method,
        url: xhr.url
      },
      description: `${xhr.method} ${xhr.url}`,
      op: "http.client"
    });
    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;
    if (handlerData.xhr.setRequestHeader) {
      try {
        handlerData.xhr.setRequestHeader("sentry-trace", span.toTraceparent());
        var headerBaggageString = handlerData.xhr.getRequestHeader && handlerData.xhr.getRequestHeader(BAGGAGE_HEADER_NAME);
        handlerData.xhr.setRequestHeader(
          BAGGAGE_HEADER_NAME,
          mergeAndSerializeBaggage(activeTransaction.getBaggage(), headerBaggageString)
        );
      } catch (_) {
      }
    }
  }
}

// node_modules/@sentry/tracing/esm/browser/router.js
var global3 = getGlobalObject();
function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) {
  if (!global3 || !global3.location) {
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn("Could not initialize routing instrumentation due to invalid location");
    return;
  }
  let startingUrl = global3.location.href;
  let activeTransaction;
  if (startTransactionOnPageLoad) {
    activeTransaction = customStartTransaction({
      name: global3.location.pathname,
      op: "pageload",
      metadata: { source: "url" }
    });
  }
  if (startTransactionOnLocationChange) {
    addInstrumentationHandler("history", ({ to, from }) => {
      if (from === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {
        startingUrl = void 0;
        return;
      }
      if (from !== to) {
        startingUrl = void 0;
        if (activeTransaction) {
          (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);
          activeTransaction.finish();
        }
        activeTransaction = customStartTransaction({
          name: global3.location.pathname,
          op: "navigation",
          metadata: { source: "url" }
        });
      }
    });
  }
}

// node_modules/@sentry/tracing/esm/browser/browsertracing.js
var BROWSER_TRACING_INTEGRATION_ID = "BrowserTracing";
var DEFAULT_BROWSER_TRACING_OPTIONS = {
  idleTimeout: DEFAULT_IDLE_TIMEOUT,
  finalTimeout: DEFAULT_FINAL_TIMEOUT,
  markBackgroundTransactions: true,
  routingInstrumentation: instrumentRoutingWithDefaults,
  startTransactionOnLocationChange: true,
  startTransactionOnPageLoad: true,
  _experiments: { enableLongTask: true },
  ...defaultRequestInstrumentationOptions
};
var BrowserTracing = class {
  __init() {
    this.name = BROWSER_TRACING_INTEGRATION_ID;
  }
  constructor(_options) {
    ;
    BrowserTracing.prototype.__init.call(this);
    let tracingOrigins = defaultRequestInstrumentationOptions.tracingOrigins;
    if (_options) {
      if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins)) {
        tracingOrigins = _options.tracingOrigins;
      } else {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && (this._emitOptionsWarning = true);
      }
    }
    this.options = {
      ...DEFAULT_BROWSER_TRACING_OPTIONS,
      ..._options,
      tracingOrigins
    };
    const { _metricOptions } = this.options;
    startTrackingWebVitals(_metricOptions && _metricOptions._reportAllChanges);
    if (_optionalChain([this, "access", (_2) => _2.options, "access", (_3) => _3._experiments, "optionalAccess", (_4) => _4.enableLongTask])) {
      startTrackingLongTasks();
    }
  }
  setupOnce(_, getCurrentHub2) {
    this._getCurrentHub = getCurrentHub2;
    if (this._emitOptionsWarning) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn(
        "[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace."
      );
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn(
        `[Tracing] We added a reasonable default for you: ${defaultRequestInstrumentationOptions.tracingOrigins}`
      );
    }
    const {
      routingInstrumentation: instrumentRouting,
      startTransactionOnLocationChange,
      startTransactionOnPageLoad,
      markBackgroundTransactions,
      traceFetch,
      traceXHR,
      tracingOrigins,
      shouldCreateSpanForRequest
    } = this.options;
    instrumentRouting(
      (context) => this._createRouteTransaction(context),
      startTransactionOnPageLoad,
      startTransactionOnLocationChange
    );
    if (markBackgroundTransactions) {
      registerBackgroundTabDetection();
    }
    instrumentOutgoingRequests({ traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest });
  }
  _createRouteTransaction(context) {
    if (!this._getCurrentHub) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);
      return void 0;
    }
    const { beforeNavigate, idleTimeout, finalTimeout } = this.options;
    var parentContextFromHeader = context.op === "pageload" ? extractTraceDataFromMetaTags() : void 0;
    var expandedContext = {
      ...context,
      ...parentContextFromHeader,
      ...parentContextFromHeader && {
        metadata: {
          ...context.metadata,
          ...parentContextFromHeader.metadata
        }
      },
      trimEnd: true
    };
    var modifiedContext = typeof beforeNavigate === "function" ? beforeNavigate(expandedContext) : expandedContext;
    var finalContext = modifiedContext === void 0 ? { ...expandedContext, sampled: false } : modifiedContext;
    finalContext.metadata = finalContext.name !== expandedContext.name ? { ...finalContext.metadata, source: "custom" } : finalContext.metadata;
    if (finalContext.sampled === false) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);
    }
    (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);
    var hub = this._getCurrentHub();
    const { location } = getGlobalObject();
    var idleTransaction = startIdleTransaction(
      hub,
      finalContext,
      idleTimeout,
      finalTimeout,
      true,
      { location }
    );
    idleTransaction.registerBeforeFinishCallback((transaction) => {
      addPerformanceEntries(transaction);
      transaction.setTag(
        "sentry_reportAllChanges",
        Boolean(this.options._metricOptions && this.options._metricOptions._reportAllChanges)
      );
    });
    return idleTransaction;
  }
};
function extractTraceDataFromMetaTags() {
  var sentrytraceValue = getMetaContent("sentry-trace");
  var baggageValue = getMetaContent("baggage");
  var sentrytraceData = sentrytraceValue ? extractTraceparentData(sentrytraceValue) : void 0;
  var baggage = parseBaggageSetMutability(baggageValue, sentrytraceValue);
  if (sentrytraceData || baggage) {
    return {
      ...sentrytraceData && sentrytraceData,
      ...baggage && { metadata: { baggage } }
    };
  }
  return void 0;
}
function getMetaContent(metaName) {
  var globalObject = getGlobalObject();
  if (globalObject.document && globalObject.document.querySelector) {
    var el = globalObject.document.querySelector(`meta[name=${metaName}]`);
    return el ? el.getAttribute("content") : null;
  } else {
    return null;
  }
}

// node_modules/@sentry/tracing/esm/spanstatus.js
var SpanStatus;
(function(SpanStatus2) {
  var Ok = "ok";
  SpanStatus2["Ok"] = Ok;
  var DeadlineExceeded = "deadline_exceeded";
  SpanStatus2["DeadlineExceeded"] = DeadlineExceeded;
  var Unauthenticated = "unauthenticated";
  SpanStatus2["Unauthenticated"] = Unauthenticated;
  var PermissionDenied = "permission_denied";
  SpanStatus2["PermissionDenied"] = PermissionDenied;
  var NotFound = "not_found";
  SpanStatus2["NotFound"] = NotFound;
  var ResourceExhausted = "resource_exhausted";
  SpanStatus2["ResourceExhausted"] = ResourceExhausted;
  var InvalidArgument = "invalid_argument";
  SpanStatus2["InvalidArgument"] = InvalidArgument;
  var Unimplemented = "unimplemented";
  SpanStatus2["Unimplemented"] = Unimplemented;
  var Unavailable = "unavailable";
  SpanStatus2["Unavailable"] = Unavailable;
  var InternalError = "internal_error";
  SpanStatus2["InternalError"] = InternalError;
  var UnknownError = "unknown_error";
  SpanStatus2["UnknownError"] = UnknownError;
  var Cancelled = "cancelled";
  SpanStatus2["Cancelled"] = Cancelled;
  var AlreadyExists = "already_exists";
  SpanStatus2["AlreadyExists"] = AlreadyExists;
  var FailedPrecondition = "failed_precondition";
  SpanStatus2["FailedPrecondition"] = FailedPrecondition;
  var Aborted = "aborted";
  SpanStatus2["Aborted"] = Aborted;
  var OutOfRange = "out_of_range";
  SpanStatus2["OutOfRange"] = OutOfRange;
  var DataLoss = "data_loss";
  SpanStatus2["DataLoss"] = DataLoss;
})(SpanStatus || (SpanStatus = {}));

// node_modules/@sentry/tracing/esm/index.js
if (typeof __SENTRY_TRACING__ === "undefined" || __SENTRY_TRACING__) {
  addExtensionMethods();
}
export {
  BROWSER_TRACING_INTEGRATION_ID,
  BrowserTracing,
  IdleTransaction,
  integrations_exports as Integrations,
  Span,
  SpanStatus,
  TRACEPARENT_REGEXP,
  Transaction,
  addExtensionMethods,
  defaultRequestInstrumentationOptions,
  extractTraceparentData,
  getActiveTransaction,
  hasTracingEnabled,
  instrumentOutgoingRequests,
  spanStatusfromHttpCode,
  startIdleTransaction,
  stripUrlQueryAndFragment
};
//# sourceMappingURL=@sentry_tracing.js.map
