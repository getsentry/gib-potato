Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@sentry/utils');
var utils$1 = require('../utils.js');

var DEFAULT_TRACING_ORIGINS = ['localhost', /^\//];

/** Options for Request Instrumentation */

var defaultRequestInstrumentationOptions = {
  traceFetch: true,
  traceXHR: true,
  tracingOrigins: DEFAULT_TRACING_ORIGINS,
};

/** Registers span creators for xhr and fetch requests  */
function instrumentOutgoingRequests(_options) {
    const { traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest } = {
    ...defaultRequestInstrumentationOptions,
    ..._options,
  };

  // We should cache url -> decision so that we don't have to compute
  // regexp everytime we create a request.
  var urlMap = {};

  var defaultShouldCreateSpan = (url) => {
    if (urlMap[url]) {
      return urlMap[url];
    }
    var origins = tracingOrigins;
    urlMap[url] =
      origins.some((origin) => utils.isMatchingPattern(url, origin)) &&
      !utils.isMatchingPattern(url, 'sentry_key');
    return urlMap[url];
  };

  // We want that our users don't have to re-implement shouldCreateSpanForRequest themselves
  // That's why we filter out already unwanted Spans from tracingOrigins
  let shouldCreateSpan = defaultShouldCreateSpan;
  if (typeof shouldCreateSpanForRequest === 'function') {
    shouldCreateSpan = (url) => {
      return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
    };
  }

  var spans = {};

  if (traceFetch) {
    utils.addInstrumentationHandler('fetch', (handlerData) => {
      fetchCallback(handlerData, shouldCreateSpan, spans);
    });
  }

  if (traceXHR) {
    utils.addInstrumentationHandler('xhr', (handlerData) => {
      xhrCallback(handlerData, shouldCreateSpan, spans);
    });
  }
}

/**
 * Create and track fetch request spans
 */
function fetchCallback(
  handlerData,
  shouldCreateSpan,
  spans,
) {
  if (!utils$1.hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
    return;
  }

  if (handlerData.endTimestamp) {
    var spanId = handlerData.fetchData.__span;
    if (!spanId) return;

    var span = spans[spanId];
    if (span) {
      if (handlerData.response) {
        // TODO (kmclb) remove this once types PR goes through
                span.setHttpStatus(handlerData.response.status);
      } else if (handlerData.error) {
        span.setStatus('internal_error');
      }
      span.finish();

            delete spans[spanId];
    }
    return;
  }

  var activeTransaction = utils$1.getActiveTransaction();
  if (activeTransaction) {
    var span = activeTransaction.startChild({
      data: {
        ...handlerData.fetchData,
        type: 'fetch',
      },
      description: `${handlerData.fetchData.method} ${handlerData.fetchData.url}`,
      op: 'http.client',
    });

    handlerData.fetchData.__span = span.spanId;
    spans[span.spanId] = span;

    var request = (handlerData.args[0] = handlerData.args[0] );
        var options = (handlerData.args[1] = (handlerData.args[1] ) || {});
    options.headers = addTracingHeaders(request, activeTransaction.getBaggage(), span, options);
  }
}

function addTracingHeaders(
  request,
  incomingBaggage,
  span,
  options,
) {
  let headers = options.headers;

  if (utils.isInstanceOf(request, Request)) {
    headers = (request ).headers;
  }

  if (headers) {
        if (typeof headers.append === 'function') {
            headers.append('sentry-trace', span.toTraceparent());
            headers.append(utils.BAGGAGE_HEADER_NAME, utils.mergeAndSerializeBaggage(incomingBaggage, headers.get(utils.BAGGAGE_HEADER_NAME)));
    } else if (Array.isArray(headers)) {
      const [, headerBaggageString] = headers.find(([key, _]) => key === utils.BAGGAGE_HEADER_NAME);
      headers = [
        ...headers,
        ['sentry-trace', span.toTraceparent()],
        [utils.BAGGAGE_HEADER_NAME, utils.mergeAndSerializeBaggage(incomingBaggage, headerBaggageString)],
      ];
    } else {
      headers = {
        ...headers,
        'sentry-trace': span.toTraceparent(),
                baggage: utils.mergeAndSerializeBaggage(incomingBaggage, headers.baggage),
      };
    }
  } else {
    headers = { 'sentry-trace': span.toTraceparent(), baggage: utils.mergeAndSerializeBaggage(incomingBaggage) };
  }
  return headers;
}

/**
 * Create and track xhr request spans
 */
function xhrCallback(
  handlerData,
  shouldCreateSpan,
  spans,
) {
  if (
    !utils$1.hasTracingEnabled() ||
    (handlerData.xhr && handlerData.xhr.__sentry_own_request__) ||
    !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))
  ) {
    return;
  }

  var xhr = handlerData.xhr.__sentry_xhr__;

  // check first if the request has finished and is tracked by an existing span which should now end
  if (handlerData.endTimestamp) {
    var spanId = handlerData.xhr.__sentry_xhr_span_id__;
    if (!spanId) return;

    var span = spans[spanId];
    if (span) {
      span.setHttpStatus(xhr.status_code);
      span.finish();

            delete spans[spanId];
    }
    return;
  }

  // if not, create a new span to track it
  var activeTransaction = utils$1.getActiveTransaction();
  if (activeTransaction) {
    var span = activeTransaction.startChild({
      data: {
        ...xhr.data,
        type: 'xhr',
        method: xhr.method,
        url: xhr.url,
      },
      description: `${xhr.method} ${xhr.url}`,
      op: 'http.client',
    });

    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;

    if (handlerData.xhr.setRequestHeader) {
      try {
        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());

        var headerBaggageString =
          handlerData.xhr.getRequestHeader && handlerData.xhr.getRequestHeader(utils.BAGGAGE_HEADER_NAME);

        handlerData.xhr.setRequestHeader(
          utils.BAGGAGE_HEADER_NAME,
          utils.mergeAndSerializeBaggage(activeTransaction.getBaggage(), headerBaggageString),
        );
      } catch (_) {
        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.
      }
    }
  }
}

exports.DEFAULT_TRACING_ORIGINS = DEFAULT_TRACING_ORIGINS;
exports.defaultRequestInstrumentationOptions = defaultRequestInstrumentationOptions;
exports.fetchCallback = fetchCallback;
exports.instrumentOutgoingRequests = instrumentOutgoingRequests;
exports.xhrCallback = xhrCallback;
//# sourceMappingURL=request.js.map
