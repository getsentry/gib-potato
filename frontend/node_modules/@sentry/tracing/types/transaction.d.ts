import { Hub } from '@sentry/hub';
import { Baggage, MeasurementUnit, Transaction as TransactionInterface, TransactionContext, TransactionMetadata } from '@sentry/types';
import { Span as SpanClass } from './span';
/** JSDoc */
export declare class Transaction extends SpanClass implements TransactionInterface {
    metadata: TransactionMetadata;
    /**
     * The reference to the current hub.
     */
    readonly _hub: Hub;
    private _name;
    private _measurements;
    private _trimEnd?;
    /**
     * This constructor should never be called manually. Those instrumenting tracing should use
     * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.
     * @internal
     * @hideconstructor
     * @hidden
     */
    constructor(transactionContext: TransactionContext, hub?: Hub);
    /** Getter for `name` property */
    get name(): string;
    /** Setter for `name` property, which also sets `source` */
    set name(newName: string);
    /**
     * JSDoc
     */
    setName(name: string, source?: TransactionMetadata['source']): void;
    /**
     * Attaches SpanRecorder to the span itself
     * @param maxlen maximum number of spans that can be recorded
     */
    initSpanRecorder(maxlen?: number): void;
    /**
     * @inheritDoc
     */
    setMeasurement(name: string, value: number, unit?: MeasurementUnit): void;
    /**
     * @inheritDoc
     */
    setMetadata(newMetadata: Partial<TransactionMetadata>): void;
    /**
     * @inheritDoc
     */
    finish(endTimestamp?: number): string | undefined;
    /**
     * @inheritDoc
     */
    toContext(): TransactionContext;
    /**
     * @inheritDoc
     */
    updateWithContext(transactionContext: TransactionContext): this;
    /**
     * @inheritdoc
     *
     * @experimental
     */
    getBaggage(): Baggage;
    /**
     * Collects and adds data to the passed baggage object.
     *
     * Note: This function does not explicitly check if the passed baggage object is allowed
     * to be modified. Implicitly, `setBaggageValue` will not make modification to the object
     * if it was already set immutable.
     *
     * After adding the data, the baggage object is set immutable to prevent further modifications.
     *
     * @param baggage
     *
     * @returns modified and immutable baggage object
     */
    private _populateBaggageWithSentryValues;
}
//# sourceMappingURL=transaction.d.ts.map