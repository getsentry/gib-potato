{"version":3,"file":"tracing.js","sources":["../../src/tracing.ts"],"sourcesContent":["import { getCurrentHub } from '@sentry/browser';\nimport { Span, Transaction } from '@sentry/types';\nimport { logger, timestampInSeconds } from '@sentry/utils';\n\nimport { formatComponentName } from './components';\nimport { DEFAULT_HOOKS } from './constants';\nimport { Hook, Operation, TracingOptions, ViewModel, Vue } from './types';\n\nconst VUE_OP = 'ui.vue';\n\ntype Mixins = Parameters<Vue['mixin']>[0];\n\ninterface VueSentry extends ViewModel {\n  readonly $root: VueSentry;\n  $_sentrySpans?: {\n    [key: string]: Span;\n  };\n  $_sentryRootSpan?: Span;\n  $_sentryRootSpanTimer?: ReturnType<typeof setTimeout>;\n}\n\n// Mappings from operation to corresponding lifecycle hook.\nconst HOOKS: { [key in Operation]: Hook[] } = {\n  activate: ['activated', 'deactivated'],\n  create: ['beforeCreate', 'created'],\n  destroy: ['beforeDestroy', 'destroyed'],\n  mount: ['beforeMount', 'mounted'],\n  update: ['beforeUpdate', 'updated'],\n};\n\n/** Grabs active transaction off scope, if any */\nfunction getActiveTransaction(): Transaction | undefined {\n  return getCurrentHub().getScope()?.getTransaction();\n}\n\n/** Finish top-level span and activity with a debounce configured using `timeout` option */\nfunction finishRootSpan(vm: VueSentry, timestamp: number, timeout: number): void {\n  if (vm.$_sentryRootSpanTimer) {\n    clearTimeout(vm.$_sentryRootSpanTimer);\n  }\n\n  vm.$_sentryRootSpanTimer = setTimeout(() => {\n    if (vm.$root?.$_sentryRootSpan) {\n      vm.$root.$_sentryRootSpan.finish(timestamp);\n      vm.$root.$_sentryRootSpan = undefined;\n    }\n  }, timeout);\n}\n\nexport const createTracingMixins = (options: TracingOptions): Mixins => {\n  const hooks = (options.hooks || [])\n    .concat(DEFAULT_HOOKS)\n    // Removing potential duplicates\n    .filter((value, index, self) => self.indexOf(value) === index);\n\n  const mixins: Mixins = {};\n\n  for (const operation of hooks) {\n    // Retrieve corresponding hooks from Vue lifecycle.\n    // eg. mount => ['beforeMount', 'mounted']\n    const internalHooks = HOOKS[operation];\n    if (!internalHooks) {\n      __DEBUG_BUILD__ && logger.warn(`Unknown hook: ${operation}`);\n      continue;\n    }\n\n    for (const internalHook of internalHooks) {\n      mixins[internalHook] = function (this: VueSentry) {\n        const isRoot = this.$root === this;\n\n        if (isRoot) {\n          const activeTransaction = getActiveTransaction();\n          if (activeTransaction) {\n            this.$_sentryRootSpan =\n              this.$_sentryRootSpan ||\n              activeTransaction.startChild({\n                description: 'Application Render',\n                op: VUE_OP,\n              });\n          }\n        }\n\n        // Skip components that we don't want to track to minimize the noise and give a more granular control to the user\n        const name = formatComponentName(this, false);\n        const shouldTrack = Array.isArray(options.trackComponents)\n          ? options.trackComponents.indexOf(name) > -1\n          : options.trackComponents;\n\n        // We always want to track root component\n        if (!isRoot && !shouldTrack) {\n          return;\n        }\n\n        this.$_sentrySpans = this.$_sentrySpans || {};\n\n        // Start a new span if current hook is a 'before' hook.\n        // Otherwise, retrieve the current span and finish it.\n        if (internalHook == internalHooks[0]) {\n          const activeTransaction = this.$root?.$_sentryRootSpan || getActiveTransaction();\n          if (activeTransaction) {\n            this.$_sentrySpans[operation] = activeTransaction.startChild({\n              description: `Vue <${name}>`,\n              op: `${VUE_OP}.${operation}`,\n            });\n          }\n        } else {\n          // The span should already be added via the first handler call (in the 'before' hook)\n          const span = this.$_sentrySpans[operation];\n          // The before hook did not start the tracking span, so the span was not added.\n          // This is probably because it happened before there is an active transaction\n          if (!span) return;\n\n          span.finish();\n          finishRootSpan(this, timestampInSeconds(), options.timeout);\n        }\n      };\n    }\n  }\n\n  return mixins;\n};\n"],"names":[],"mappings":";;;;;;AAQA;;AAaA;AACA;;;;;;AAMA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyEA;;"}