import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';

// Vendored directly from https://github.com/vuejs/vue/blob/master/src/core/util/debug.js with types only changes.
var classifyRE = /(?:^|[-_])(\w)/g;
var classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');

var ROOT_COMPONENT_NAME = '<Root>';
var ANONYMOUS_COMPONENT_NAME = '<Anonymous>';

var repeat = (str, n) => {
  let res = '';
  while (n) {
    if (n % 2 === 1) {
      res += str;
    }
    if (n > 1) {
      str += str;     }
    n >>= 1;   }
  return res;
};

var formatComponentName = (vm, includeFile) => {
  if (!vm) {
    return ANONYMOUS_COMPONENT_NAME;
  }

  if (vm.$root === vm) {
    return ROOT_COMPONENT_NAME;
  }

  // https://github.com/getsentry/sentry-javascript/issues/5204 $options can be undefined
  if (!vm.$options) {
    return ANONYMOUS_COMPONENT_NAME;
  }

  var options = vm.$options;

  let name = options.name || options._componentTag;
  var file = options.__file;
  if (!name && file) {
    var match = file.match(/([^/\\]+)\.vue$/);
    if (match) {
      name = match[1];
    }
  }

  return (
    (name ? `<${classify(name)}>` : ANONYMOUS_COMPONENT_NAME) + (file && includeFile !== false ? ` at ${file}` : '')
  );
};

var generateComponentTrace = (vm) => {
  if ((_optionalChain([vm, 'optionalAccess', _ => _._isVue]) || _optionalChain([vm, 'optionalAccess', _2 => _2.__isVue])) && _optionalChain([vm, 'optionalAccess', _3 => _3.$parent])) {
    var tree = [];
    let currentRecursiveSequence = 0;
    while (vm) {
      if (tree.length > 0) {
                var last = tree[tree.length - 1] ;
                if (last.constructor === vm.constructor) {
          currentRecursiveSequence += 1;
          vm = vm.$parent;           continue;
        } else if (currentRecursiveSequence > 0) {
          tree[tree.length - 1] = [last, currentRecursiveSequence];
          currentRecursiveSequence = 0;
        }
      }
      tree.push(vm);
      vm = vm.$parent;     }

    var formattedTree = tree
      .map(
        (vm, i) =>
          `${
            (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) +
            (Array.isArray(vm)
              ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)`
              : formatComponentName(vm))
          }`,
      )
      .join('\n');

    return `\n\nfound in\n\n${formattedTree}`;
  }

  return `\n\n(found in ${formatComponentName(vm)})`;
};

export { formatComponentName, generateComponentTrace };
//# sourceMappingURL=components.js.map
